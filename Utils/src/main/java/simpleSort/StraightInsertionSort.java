package simpleSort;
/**
 * 直接插入排序，直接插入排序的思想是从头到尾将每个位置的值都和前面排好序的相比较（这里假定第一个已经排好序，一个数本身不存在
 * 序列）相当于就是把后续的无序序列一个一个拿出来插到有序序列里面去。直接插入排序相比较简单选择排序，相当于是简单的优化了
 * 当队列有序度比较高时的排序效率。但是当有序度比较低的时候其实效率反而不如简单选择排序
 * 时间复杂度分析：
 * 有序队列：比较n-1次，不移动，复杂度为n
 * 逆序队列：比较（n+2）（n-1）/2，移动（n+4）（n-1）/2(比冒泡要快，冒泡有个系数3，所以冒泡就算改进了之后加上概率的因素还是
 * 会低于简单选择排序和直接插入排序的效率的)
 * 综合下来的时间复杂度在n2/4左右
 * 1w个较无序的队列，时间大概在131ms ，有序队列耗时0-2ms
 * 10w个较无序的队列，时间大概在11s左右，有序队列耗时16ms左右，差距明显！
 * 所以综合下来考虑，在简单排序中虽然所有的时间复杂度都是n2，但是性能直接插入排序>简单选择排序>冒泡排序
 * @author Administrator
 *
 */
public class StraightInsertionSort {
	public static int[] sort(int[] arr) {
		if(arr==null||arr.length<2) {
			return arr;
		}
		for(int i=1;i<arr.length;i++) {
			if(arr[i-1]>arr[i]) {//这里的比较在下面会再做一次
				int j;
				int temp = arr[i];
				 //走到这里的时候，多进行了一次上面注释的比较
				//也就是说当走到这里的时候，每次交换相比冒泡和简单选择排序都多比较了一次
				for (j = i-1;j>=0&&temp<arr[j]; j--) {
					arr[j+1]=arr[j];
				}
				arr[j+1]=temp;
			}
		}
		return arr;
	}
}
