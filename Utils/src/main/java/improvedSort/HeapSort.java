package improvedSort;

import littleCase.Swap;

/**
 * Floyd 和Williams发明,利用完全二叉树的算法，MergingSort归并排序也是利用完全二叉树的算法，这样的算法效率一般都比较高。
 * 对简单选择排序的改进，简单选择排序比较一个区间的最小值然后放到合适位置，但是会存在重复比较的情况，也就是说没有记录到
 * 有用的比较结果。堆排序就是利用一种新的数据结构来记录这个方式
 * 
 *堆的定义：堆是具有下列性质的完全二叉树（和满二叉树的标号一样的二叉树）:
 *       每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆
 *或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
 *实验结果：
 *数组为9，耗时10ms，因为要进行一系列的调用，耗时在这，其实运行没怎么耗时
 *数组为1w，耗时30ms
 *数组为10w，耗时60ms
 *数组为100w，耗时500ms
 *数组为1000w，耗时8-9s
 *数组为1e，耗时141s左右
 *可以看出和shell排序差别不大，基本在一个数量级，比shell排序慢一些是因为要构建堆，加了一个n
 * @author Administrator
 * 
 */
public class HeapSort {
	public static int [] sort(int[] arr) {
		if(arr==null || arr.length < 2 ){
            return arr;
        }
		int i;
		/**
		 *第一步： 将序列转化为堆的形式（此处以大顶堆为例）
		 *这里为什么不用从1到arr.length，是因为只需要从下往上、从右到左，
		 *将每个非终端结点(非叶结点)当作根结点，将其和其子树调整成大顶堆即可。整个堆就变成了大顶堆，这个时候相当于已经记录了
		 *一些比较结果了，后面不需改动，也不需要比较这些结果，这里就要要求对方法的设计要巧妙，
		 *作者能够想出堆这个数据结构，真的很厉害！
		 */
		for(i=arr.length/2;i>0;i--) {
			heapAdjust(arr, i, arr.length);
		}
		/**
		 * 第二步： 交换元素，并将交换过后的序列转换为堆的形式，
		 * 这里因为之前是堆的形式，实际上已经记录了一些比较结果了，然后每次都是堆的数据结构，所以每次都在做有用的操作
		 */
		for(i=arr.length;i>0;i--) {
			Swap.swap(arr, 0,i-1);
			heapAdjust(arr, 1, i-1);
		}
		return arr;
	}
	private static int[] heapAdjust(int[]arr, int s,int m) {
		
		//内部的－1是因为堆的数量关系和数组的数量关系不一致，然后因为0*任何数都为0，所以不能从0开始，故而这么设计
		int temp=arr[s-1];
		//代码一开始设计变量的时候可以都放在外面，最后改一些细节的时候，再修改一下，好代码都是改出来的，有道理！
		for(int j=2*s;j<=m;j*=2) {
			//先判断是否有右孩子，且比较右孩子是否大于左孩子，如果大就加1，用右孩子来做替换
			if(j<m&&arr[j-1]<arr[j])++j;
			//判断是否孩子大于父节点，如果大于就继续往下走（用反向考虑，实际代码读起来更方便）
			if(temp>=arr[j-1])break;
			/**
			 * 将最大值赋值给父节点，因为是循环，这一步实际上是在将堆下面较大的值放到更上一层的结点上去，
			 * 这个循环结束的时候，会有一个重复的值，循环外面的一步赋值，就是把原本的值覆盖掉这个重复的值，
			 * 实际上是一种替换操作，不过是循环中和循环外，所以可能难理解一些
			 */
			arr[s-1]=arr[j-1];
			//这一步是：继续往下一级走，j变成原来的两倍，s也变成（两倍j）的父节点
			s=j;
		}
		/**
		 * 因为s已经变为第一次循环的j了，所以这个时候的arr[s-1]和上面的不同，实际是为孩子结点赋值，
		 * 这个s是循环结束之后最终的s，也就是最后的一个孩子结点,然后把一开始的那个值放到这个位置
		 */
		arr[s-1]=temp;
		return arr;
		
	} 
	
}

